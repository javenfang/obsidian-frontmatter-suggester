import {
	App,
	Editor,
	EditorPosition,
	EditorSuggest,
	EditorSuggestContext,
	EditorSuggestTriggerInfo,
	TFile
} from 'obsidian';
import { FieldRule, PluginSettings, SuggestionItem, OptionItem } from './types';
import { FrontmatterParser } from './frontmatter-parser';

export class FrontmatterSuggester extends EditorSuggest<SuggestionItem> {
	private settings: PluginSettings;

	constructor(app: App, settings: PluginSettings) {
		super(app);
		this.settings = settings;
	}

	updateSettings(settings: PluginSettings) {
		this.settings = settings;
	}

	/**
	 * Determine when to show suggestions
	 */
	onTrigger(
		cursor: EditorPosition,
		editor: Editor,
		file: TFile | null
	): EditorSuggestTriggerInfo | null {
		// Must have a file
		if (!file) {
			return null;
		}

		// Must be in frontmatter
		if (!FrontmatterParser.isInFrontmatter(cursor, editor)) {
			return null;
		}

		// Get current field path
		const context = FrontmatterParser.getCurrentFieldPath(cursor, editor);
		if (!context) return null;

		// Find matching rule
		const matchingRule = this.findMatchingRule(context.path);
		if (!matchingRule || !matchingRule.enabled) {
			return null;
		}

		// Get suggestions to check if there are any
		const suggestions = this.generateSuggestions(matchingRule, cursor, editor);
		if (suggestions.length === 0) {
			return null;
		}

		// Calculate start position: after the colon and space
		const currentLine = editor.getLine(cursor.line);
		const fieldName = FrontmatterParser.extractFieldName(currentLine);
		let startCh: number;
		if (fieldName) {
			// Position after field name + colon + optional space
			startCh = context.indent + fieldName.length + 1; // +1 for ":"
			// Skip spaces after colon
			while (startCh < currentLine.length && currentLine[startCh] === ' ') {
				startCh++;
			}
		} else {
			// No field name, we're on an empty sub-item line
			startCh = cursor.ch;
		}

		// Query should be the text from startCh to cursor position
		const query = currentLine.substring(startCh, cursor.ch);

		const triggerInfo = {
			start: { line: cursor.line, ch: startCh },
			end: cursor,
			query: query
		};

		return triggerInfo;
	}

	/**
	 * Generate suggestion list
	 */
	getSuggestions(context: EditorSuggestContext): SuggestionItem[] {
		const cursor = context.editor.getCursor();
		const fieldContext = FrontmatterParser.getCurrentFieldPath(cursor, context.editor);
		if (!fieldContext) {
			return [];
		}

		const matchingRule = this.findMatchingRule(fieldContext.path);
		if (!matchingRule || !matchingRule.enabled) {
			return [];
		}

		let suggestions = this.generateSuggestions(matchingRule, cursor, context.editor);
		if (suggestions.length === 0) {
			return [];
		}

		// Filter by query
		if (context.query && context.query.trim() !== '') {
			suggestions = this.filterSuggestions(suggestions, context.query);
		}

		// Limit to max suggestions
		const result = suggestions.slice(0, this.settings.globalSettings.maxSuggestions);
		return result;
	}

	/**
	 * Render each suggestion
	 */
	renderSuggestion(suggestion: SuggestionItem, el: HTMLElement): void {
		el.createDiv({ cls: 'frontmatter-suggestion-item' }, (div) => {
			// Icon (if available)
			if (suggestion.option.icon && suggestion.rule.displayFormat?.showIcon !== false) {
				div.createSpan({ cls: 'frontmatter-suggestion-icon', text: suggestion.option.icon });
			}

			// Key
			div.createSpan({ cls: 'frontmatter-suggestion-key', text: suggestion.option.key });

			// Description (if available)
			if (suggestion.option.description && suggestion.rule.displayFormat?.showDescription !== false) {
				div.createSpan({ cls: 'frontmatter-suggestion-desc', text: ` - ${suggestion.option.description}` });
			}
		});
	}

	/**
	 * Handle selection
	 */
	selectSuggestion(suggestion: SuggestionItem, evt: MouseEvent | KeyboardEvent): void {
		const editor = (this.context as EditorSuggestContext).editor;
		const cursor = editor.getCursor();
		const currentLine = editor.getLine(cursor.line);

		// Get field context to determine indentation
		const fieldContext = FrontmatterParser.getCurrentFieldPath(cursor, editor);
		if (!fieldContext) return;

		// Check if current line has a field name (like "Exercises:" or "Exercises: ")
		const fieldName = FrontmatterParser.extractFieldName(currentLine);

		if (fieldName) {
			// Cursor is on a parent field line like "Exercises:"
			// Insert new line after this line with the sub-item
			const itemIndent = fieldContext.indent + 2;  // Sub-items are indented 2 more spaces
			const indentStr = ' '.repeat(itemIndent);
			const newLineText = `\n${indentStr}${suggestion.option.key}: `;

			// Insert at end of current line
			const insertPos = { line: cursor.line, ch: currentLine.length };
			editor.replaceRange(newLineText, insertPos);

			// Set cursor position at the end of inserted text
			const newCursorPos = {
				line: cursor.line + 1,
				ch: itemIndent + suggestion.option.key.length + 2  // +2 for ": "
			};
			editor.setCursor(newCursorPos);
		} else {
			// Cursor is on an empty sub-item line, just insert the item
			const itemIndent = cursor.line > 0 ? FrontmatterParser.getIndent(currentLine) : fieldContext.indent + 2;
			const indentStr = ' '.repeat(itemIndent);
			const insertText = `${indentStr}${suggestion.option.key}: `;

			// Replace from current cursor position to end of line
			const from = cursor;
			const to = { line: cursor.line, ch: currentLine.length };
			editor.replaceRange(insertText, from, to);

			// Set cursor position after inserted text
			const newCursorPos = {
				line: cursor.line,
				ch: from.ch + insertText.length
			};
			editor.setCursor(newCursorPos);
		}
	}

	/**
	 * Find matching rule for a field path
	 */
	private findMatchingRule(fieldPath: string): FieldRule | null {
		// Exact match first
		for (const rule of this.settings.rules) {
			if (rule.fieldPath === fieldPath) {
				return rule;
			}
		}

		// Check if fieldPath is under a parent field
		// e.g., "Habits Yestoday.Exercises.hiking" should match "Habits Yestoday.Exercises"
		for (const rule of this.settings.rules) {
			if (fieldPath.startsWith(rule.fieldPath + '.')) {
				return rule;
			}
		}

		return null;
	}

	/**
	 * Generate suggestions based on rule and context
	 * Determines suggestion type by checking YAML value type:
	 * - If value is an object: show attributes
	 * - If value is primitive or doesn't exist: show options
	 */
	private generateSuggestions(
		rule: FieldRule,
		cursor: EditorPosition,
		editor: Editor
	): SuggestionItem[] {
		const suggestions: SuggestionItem[] = [];

		// Get current field path with its YAML value
		const fieldContext = FrontmatterParser.getCurrentFieldPath(cursor, editor);
		if (!fieldContext) return [];

		const ruleFieldPath = rule.fieldPath || rule.parentField;

		// Calculate depth to determine if we're on parent field or child item line
		const ruleDepth = ruleFieldPath.split('.').length;
		const pathDepth = fieldContext.path.split('.').length;

		// Case 1: On parent field line (e.g., "Drugs:" when rule is "Habits Yestoday.Drugs")
		// pathDepth equals ruleDepth, and we should show options
		if (pathDepth === ruleDepth) {
			// Show options (for adding new items)
			const existingItems = FrontmatterParser.getExistingSubItemsByPath(
				ruleFieldPath,
				editor
			);

			// Generate suggestions based on source type
			switch (rule.sourceType) {
				case 'inline':
					if (rule.options) {
						for (const option of rule.options) {
							// Skip if already added
							if (existingItems.includes(option.key)) continue;

							suggestions.push({
								rule,
								option,
								displayText: this.buildDisplayText(option, rule),
								insertText: this.buildInsertText(option, rule)
							});
						}
					}
					break;

				case 'vault-tags':
					// TODO: Implement vault tags
					break;

				case 'vault-files':
					// TODO: Implement vault files
					break;

				case 'date':
					// TODO: Implement date picker
					break;

				case 'recent-values':
					// TODO: Implement recent values
					break;
			}

			return suggestions;
		}

		// Case 2: On child item line (pathDepth > ruleDepth)
		if (pathDepth > ruleDepth) {
			// If value is undefined/null, this is a newly added child item with no value yet
			// Don't show any suggestions
			if (fieldContext.value === undefined || fieldContext.value === null) {
				return [];
			}

			// If value is an object, show attribute options for it
			if (typeof fieldContext.value === 'object' && fieldContext.value !== null && !Array.isArray(fieldContext.value)) {
				// Show attribute options for this item
				if (rule.valueConfig && rule.valueConfig.attributes && rule.valueConfig.attributes.length > 0) {
					// For each attribute that has options, show them as suggestions
					for (const attribute of rule.valueConfig.attributes) {
						if (attribute.options && attribute.options.length > 0) {
							for (const option of attribute.options) {
								suggestions.push({
									rule,
									option: {
										key: option,
										description: attribute.label || attribute.name,
										icon: undefined
									},
									displayText: `${option} (${attribute.label || attribute.name})`,
									insertText: ''
								});
							}
						}
					}
				}
				// If no attribute options, return empty suggestions (no dropdown)
				return suggestions;
			}
		}

		// No suggestions for other cases
		return suggestions;
	}

	/**
	 * Filter suggestions by query
	 */
	private filterSuggestions(suggestions: SuggestionItem[], query: string): SuggestionItem[] {
		const caseSensitive = this.settings.globalSettings.caseSensitive;
		const normalizedQuery = caseSensitive ? query : query.toLowerCase();

		return suggestions.filter(suggestion => {
			const key = caseSensitive ? suggestion.option.key : suggestion.option.key.toLowerCase();
			const desc = suggestion.option.description
				? (caseSensitive ? suggestion.option.description : suggestion.option.description.toLowerCase())
				: '';

			return key.includes(normalizedQuery) || desc.includes(normalizedQuery);
		});
	}

	/**
	 * Build display text for suggestion
	 */
	private buildDisplayText(option: OptionItem, rule: FieldRule): string {
		let text = option.key;

		if (option.description && rule.displayFormat?.showDescription !== false) {
			text += ` - ${option.description}`;
		}

		if (option.icon && rule.displayFormat?.showIcon !== false) {
			text = `${option.icon} ${text}`;
		}

		return text;
	}

	/**
	 * Build insert text for suggestion
	 */
	private buildInsertText(option: OptionItem, rule: FieldRule): string {
		// Basic format: "key: "
		return `${option.key}: `;
	}

	/**
	 * Find the line number of a field
	 */
	private findFieldLine(fieldPath: string, editor: Editor): number | null {
		const bounds = FrontmatterParser.getFrontmatterBounds(editor);
		if (!bounds) return null;

		const pathParts = fieldPath.split('.');
		let currentLine = bounds.start + 1;
		let currentDepth = 0;

		while (currentLine < bounds.end) {
			const line = editor.getLine(currentLine);
			const indent = FrontmatterParser.getIndent(line);
			const expectedIndent = currentDepth * 2;

			if (indent === expectedIndent) {
				const fieldName = FrontmatterParser.extractFieldName(line);
				if (fieldName === pathParts[currentDepth]) {
					if (currentDepth === pathParts.length - 1) {
						return currentLine;
					}
					currentDepth++;
				}
			}

			currentLine++;
		}

		return null;
	}
}
